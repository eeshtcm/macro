import numpy as np
import pandas as pd

# standardise inputs
sw = swaps_df.copy()
sw["date"] = pd.to_datetime(sw["date"]).dt.date
panel = panel.copy()
panel["date"] = pd.to_datetime(panel["date"]).dt.date

# build a daily par curve lookup: wide table (rows=dates, cols=tenors)
swap_curve = sw.pivot_table(index="date", columns="tenor_yrs", values="sonia_par")

def time_to_mty_years(row):
    d = pd.to_datetime(row["date"])
    if "maturity_date" in row and pd.notna(row["maturity_date"]):
        mty = pd.to_datetime(row["maturity_date"])
        return max((mty - d).days / 365.25, 0.0)
    # fallback: approximate from maturity_year if that's all you have
    if pd.notna(row.get("maturity_year", None)):
        return max(float(int(row["maturity_year"]) - d.year), 0.0)
    return np.nan

def interp_sonia_par(d, T):
    """Linear interpolate par swap curve by tenor for date d."""
    if d not in swap_curve.index or np.isnan(T):
        return np.nan
    curve = swap_curve.loc[d].dropna()
    if curve.empty:
        return np.nan
    xs = curve.index.to_numpy(dtype=float)
    ys = curve.to_numpy(dtype=float)
    # clamp outside the available tenor range
    if T <= xs.min(): return float(ys[0])
    if T >= xs.max(): return float(ys[-1])
    j = np.searchsorted(xs, T)
    x0, x1 = xs[j-1], xs[j]
    y0, y1 = ys[j-1], ys[j]
    return float(y0 + (y1 - y0) * (T - x0) / (x1 - x0))

# compute simple ASW for every panel row
panel["ttm_yrs"] = panel.apply(time_to_mty_years, axis=1)
panel["sonia_par_T"] = panel.apply(lambda r: interp_sonia_par(r["date"], r["ttm_yrs"]), axis=1)
panel["asw"] = panel["y_close"] - panel["sonia_par_T"]   # in percentage points

# now your existing concession function can use metric="asw"
# e.g., cons_asw = make_concession_panel(panel, metric="asw", baseline_rel=-5)


plot_concession(cons_panel, buckets=("Long","Short"))
plt.show()
